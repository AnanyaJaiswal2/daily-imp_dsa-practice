# daily-imp_dsa-practice
Daily practice of important DSA problems in C++ with multiple approaches (Brute, Better, Optimal) and complexity analysis. Tracking my consistency and preparing for coding interviews.

## Arrays
| # | Problem | Approaches | Complexities |
|---|----------|------------|---------------|
| 1 | Majority Element | Brute, Better, Optimal | O(n^2), O(n), O(n) |
| 2 | Find Missing and Repeated Values | Brute | O(n^2) |
| 3 | Single Number | Bit Manipulation | O(n), O(1) |
| 4 | Kadaneâ€™s Algorithm | Kadane | O(n), O(1) |
| 5 | Merge Two Sorted Arrays | Two Pointers | O(n+m), O(1) |
| 6 | Best Time to Buy & Sell Stock II | Greedy | O(n), O(1) |
| 7 | Two Odd Occurring Numbers | Hashmap | O(n), O(n) |
| 8 | Power(x,n) | Binary Exponentiation | O(log n), O(1) |
| 9 | Container With Most Water | Two Pointers | O(n), O(1) |
| 10 | Sort 0s, 1s, 2s (Dutch Flag) | 3 Pointers | O(n), O(1) |
| 11 | 3Sum | Sorting + Two Pointers | O(n^2), O(1) |
| 12 | 4Sum | Sorting + Two Pointers | O(n^3), O(1) |
| 13 | Search in 2D Matrix | Binary Search | O(n+m), O(1) |
| 14 | Find Duplicate Number | Brute, Better, Optimal (Tortoise-Hare) TODO | O(n log n), O(n), O(1) |
| 15 | Longest Unique Substring | Sliding Window + Hashing | O(n), O(1) |
| 16 | Set Matrix Zeroes | Extra arrays for row & col marking | O(n*m), O(n+m) |
| 17 | Product of Array Except Self | Brute (Optimal TODO: Prefix-Suffix Product) | O(n^2), O(1) |
| 17 | Product of Array Except Self | Prefix-Suffix (Optimal)(Concept revision) | O(n^2), O(n), O(n) |
| 18 | Inversion Count | Merge Sort Divide & Conquer(CR) | O(n log n), O(n) |

---

## Binary Search
| # | Problem | Approaches | Complexities |
|---|----------|------------|---------------|
| 1 | Single Element in Sorted Array | Binary Search on pairs | O(log n), O(1) |
| 2 | Peak Element | Binary Search | O(log n), O(1) |
| 3 | Search in Rotated Sorted Array | Modified Binary Search | O(log n), O(1) |
| 4 | Book Allocation | Binary Search + Greedy allocation | O(n log(sum)), O(1) |
| 5 | Painter Partition | Binary Search + Greedy workers check | O(n log(sum)), O(1) |
| 6 | Aggressive Cows(revise) | Binary Search + Greedy placement | O(n log(max)), O(1) |
| 7 | Median of Two Sorted Arrays | Merge arrays (Optimal TODO: Binary Search Partitioning) | O(n+m), O(n+m) |

## Strings
| #  | Problem | Approaches | Complexities |
|----|----------|------------|---------------|
| 1 | Check if Two Strings are Anagrams | HashMap Frequency Count | O(n), O(1) |
| 2 | Check if String is Palindrome | Two Pointers | O(n), O(1) |
| 3 | Longest Common Prefix | Sort + Compare First & Last | O(n log n), O(1) |
| 4 | Reverse Words in a String | Splitting + Reverse | O(n), O(n) |
